import{_ as o,r as e,o as t,c,d as s,b as l,w as p,e as a,f as r}from"./app-d727cbc2.js";const D={},i=s("h1",{id:"_3-kotlin-面向对象",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_3-kotlin-面向对象","aria-hidden":"true"},"#"),a(" 3. Kotlin 面向对象")],-1),y={class:"table-of-contents"},d=r(`<h2 id="_3-1-类" tabindex="-1"><a class="header-anchor" href="#_3-1-类" aria-hidden="true">#</a> 3.1 类</h2><p>Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Apple</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// ...</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><p>也可以定义空类：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Empty</span></span>
<span class="line"></span></code></pre></div><p>类的属性可以用关键字 <code>var</code> 声明为可变的，否则使用只读关键字 <code>val</code> 声明为不可变。</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Runoob</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> name: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&quot;alex&quot;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> url: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&quot;https://example.com/&quot;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> city: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&quot;Jiangsu&quot;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><p>创建类的实例不需要 <code>new</code> 关键字：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">val</span><span style="color:#D4D4D4;"> site = </span><span style="color:#DCDCAA;">Apple</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"></span></code></pre></div><p>Kotlin 中的类可以有一个 <strong>主构造器</strong>，以及一个或多个 <strong>次构造器</strong>，主构造器是类头部的一部分，位于类名称之后:</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Person</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">constructor</span><span style="color:#D4D4D4;">(firstName: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;">) {}</span></span>
<span class="line"></span></code></pre></div><p>如果主构造器没有任何注解，也没有任何可见度修饰符，那么 <code>constructor</code> 关键字可以省略：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Person</span><span style="color:#D4D4D4;">(firstName: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_3-2-属性" tabindex="-1"><a class="header-anchor" href="#_3-2-属性" aria-hidden="true">#</a> 3.2 属性</h2><p>属性支持 getter/setter：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> &lt;</span><span style="color:#4EC9B0;">propertyName</span><span style="color:#D4D4D4;">&gt;[: &lt;</span><span style="color:#4EC9B0;">PropertyType</span><span style="color:#D4D4D4;">&gt;] [= &lt;property_initializer&gt;]</span></span>
<span class="line"><span style="color:#D4D4D4;">    [&lt;getter&gt;]</span></span>
<span class="line"><span style="color:#D4D4D4;">    [&lt;setter&gt;]</span></span>
<span class="line"></span></code></pre></div><p>getter 和 setter 都是可选的：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> allByDefault: </span><span style="color:#4EC9B0;">Int</span><span style="color:#D4D4D4;">? </span><span style="color:#6A9955;">// 错误：需要一个初始化语句，默认实现了 getter 和 setter 方法</span></span>
<span class="line"><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> initialized = </span><span style="color:#B5CEA8;">1</span><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">// 类型为 Int，默认实现了 getter 和 setter</span></span>
<span class="line"><span style="color:#569CD6;">val</span><span style="color:#D4D4D4;"> simple: </span><span style="color:#4EC9B0;">Int</span><span style="color:#D4D4D4;">?       </span><span style="color:#6A9955;">// 类型为 Int，默认实现 getter，但必须在构造函数中初始化</span></span>
<span class="line"><span style="color:#569CD6;">val</span><span style="color:#D4D4D4;"> inferredType = </span><span style="color:#B5CEA8;">1</span><span style="color:#D4D4D4;">   </span><span style="color:#6A9955;">// 类型为 Int，默认实现 getter</span></span>
<span class="line"></span></code></pre></div><h2 id="_3-3-继承" tabindex="-1"><a class="header-anchor" href="#_3-3-继承" aria-hidden="true">#</a> 3.3 继承</h2><p>Kotlin 中所有类都继承该 <code>Any</code> 类，它是所有类的超类，对于没有超类型声明的类是默认超类：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Example</span><span style="color:#D4D4D4;"> </span><span style="color:#6A9955;">// 从 Any 隐式继承</span></span>
<span class="line"></span></code></pre></div><p><code>Any</code> 默认提供了三个方法：</p><ul><li><code>equals()</code></li><li><code>hashCode()</code></li><li><code>toString()</code></li></ul><p>如果一个类要被继承，可以使用 <code>open</code> 关键字进行修饰：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">open</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Base</span><span style="color:#D4D4D4;">(p: </span><span style="color:#4EC9B0;">Int</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Derived</span><span style="color:#D4D4D4;">(p: </span><span style="color:#4EC9B0;">Int</span><span style="color:#D4D4D4;">) : </span><span style="color:#4EC9B0;">Base</span><span style="color:#D4D4D4;">(</span><span style="color:#4EC9B0;">p</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre></div><h2 id="_3-4-接口" tabindex="-1"><a class="header-anchor" href="#_3-4-接口" aria-hidden="true">#</a> 3.4 接口</h2><p>Kotlin 接口与 Java 类似，使用 <code>interface</code> 关键字定义接口，允许方法有默认实现：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">interface</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">MyInterface</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">fun</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">bar</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">fun</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">foo</span><span style="color:#D4D4D4;">() {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;foo&quot;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><p>接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">interface</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">MyInterface</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> name: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;"> </span><span style="color:#6A9955;">// 抽象属性 name</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"><span style="color:#D4D4D4;"> </span></span>
<span class="line"><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">MyImpl</span><span style="color:#D4D4D4;">: </span><span style="color:#4EC9B0;">MyInterface</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">override</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">var</span><span style="color:#D4D4D4;"> name: </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;"> = </span><span style="color:#CE9178;">&quot;alex&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#6A9955;">// 重写属性</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_3-5-扩展" tabindex="-1"><a class="header-anchor" href="#_3-5-扩展" aria-hidden="true">#</a> 3.5 扩展</h2><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p><p>扩展函数语法：</p><div class="language-kotlin" data-ext="kt"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">fun</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">receiverType</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">functionName</span><span style="color:#D4D4D4;">(params) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    body</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre></div>`,34);function u(C,E){const n=e("router-link");return t(),c("div",null,[i,s("nav",y,[s("ul",null,[s("li",null,[l(n,{to:"#_3-1-类"},{default:p(()=>[a("3.1 类")]),_:1})]),s("li",null,[l(n,{to:"#_3-2-属性"},{default:p(()=>[a("3.2 属性")]),_:1})]),s("li",null,[l(n,{to:"#_3-3-继承"},{default:p(()=>[a("3.3 继承")]),_:1})]),s("li",null,[l(n,{to:"#_3-4-接口"},{default:p(()=>[a("3.4 接口")]),_:1})]),s("li",null,[l(n,{to:"#_3-5-扩展"},{default:p(()=>[a("3.5 扩展")]),_:1})])])]),d])}const g=o(D,[["render",u],["__file","index.html.vue"]]);export{g as default};
