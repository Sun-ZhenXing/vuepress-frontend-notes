import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as r,c as D,b as s,a as e,w as l,e as n,d as t}from"./app-FEcl1joV.js";const i={},y=s("h1",{id:"2-vueuse-最佳实践",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#2-vueuse-最佳实践"},[s("span",null,"2. VueUse 最佳实践")])],-1),d={class:"table-of-contents"},u=t(`<div class="hint-container info"><p class="hint-container-title">Vue3 Ref 对象</p><p>在下文及后续文档中，<code>Ref</code> 对象指的是由 <code>ref()</code> 创建的响应式对象，也可以写作 ref，ref 的类型是 <code>Ref</code>。当宽泛地指代可能不止一个 <code>Ref</code> 对象时，使用 refs。</p></div><h2 id="1-解构" tabindex="-1"><a class="header-anchor" href="#1-解构"><span>1. 解构</span></a></h2><p>VueUse 中的大多数函数都会返回一个 <code>Ref</code> 对象，你可以使用 ES6 的对象解构语法来获取你需要的东西，例如：</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#C586C0;">import</span><span style="color:#D4D4D4;"> { </span><span style="color:#9CDCFE;">useMouse</span><span style="color:#D4D4D4;"> } </span><span style="color:#C586C0;">from</span><span style="color:#CE9178;"> &#39;@vueuse/core&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">// &quot;x&quot; 和 &quot;y&quot; 都是 refs</span></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#D4D4D4;"> { </span><span style="color:#4FC1FF;">x</span><span style="color:#D4D4D4;">, </span><span style="color:#4FC1FF;">y</span><span style="color:#D4D4D4;"> } = </span><span style="color:#DCDCAA;">useMouse</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">x</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> mouse</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useMouse</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">mouse</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">x</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre></div><p>如果你喜欢把它们作为对象属性的样式来使用，你可以通过使用 <code>reactive()</code> 来解除对 refs 的包装，例如：</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#C586C0;">import</span><span style="color:#D4D4D4;"> { </span><span style="color:#9CDCFE;">reactive</span><span style="color:#D4D4D4;"> } </span><span style="color:#C586C0;">from</span><span style="color:#CE9178;"> &#39;vue&#39;</span></span>
<span class="line"><span style="color:#C586C0;">import</span><span style="color:#D4D4D4;"> { </span><span style="color:#9CDCFE;">useMouse</span><span style="color:#D4D4D4;"> } </span><span style="color:#C586C0;">from</span><span style="color:#CE9178;"> &#39;@vueuse/core&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> mouse</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">reactive</span><span style="color:#D4D4D4;">(</span><span style="color:#DCDCAA;">useMouse</span><span style="color:#D4D4D4;">())</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">// &quot;x&quot; 和 &quot;y&quot; 将自动解包装，不需要 \`.value\`</span></span>
<span class="line"><span style="color:#9CDCFE;">console</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">log</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">mouse</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">x</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre></div><h2 id="2-清除副作用" tabindex="-1"><a class="header-anchor" href="#2-清除副作用"><span>2. 清除副作用</span></a></h2><p>类似于 Vue 的 <code>watch</code> 和 <code>computed</code> 在组件被卸载时将被处置，VueUse 的函数也会自动清理副作用。</p><p>例如，<code>useEventListener</code> 会在组件卸载时调用 <code>removeEventListener</code>，所以你不需要担心这个问题。</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#6A9955;">// 将会自动清理</span></span>
<span class="line"><span style="color:#DCDCAA;">useEventListener</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;mousemove&#39;</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {})</span></span>
<span class="line"></span></code></pre></div><p>所有 VueUse 函数都遵循这个惯例。</p><p>为了手动处理副作用，一些函数像 <code>watch</code> 函数一样返回一个停止处理程序。例如：</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> stop</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useEventListener</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;mousemove&#39;</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">// 手动解除事件监听器</span></span>
<span class="line"><span style="color:#DCDCAA;">stop</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"></span></code></pre></div><p>虽然不是所有的函数都会返回处理程序，但一个更通用的解决方案是使用 Vue 的 <code>effectScope</code> API。</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#C586C0;">import</span><span style="color:#D4D4D4;"> { </span><span style="color:#9CDCFE;">effectScope</span><span style="color:#D4D4D4;"> } </span><span style="color:#C586C0;">from</span><span style="color:#CE9178;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> scope</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">effectScope</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9CDCFE;">scope</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">run</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#6A9955;">  // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">  useEventListener</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;mousemove&#39;</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {})</span></span>
<span class="line"><span style="color:#DCDCAA;">  onClickOutside</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">el</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {})</span></span>
<span class="line"><span style="color:#DCDCAA;">  watch</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">source</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {})</span></span>
<span class="line"><span style="color:#D4D4D4;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">// 所有在 \`scope.run\` 中调用的组合函数将自动解除</span></span>
<span class="line"><span style="color:#9CDCFE;">scope</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">stop</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"></span></code></pre></div>`,15),C={href:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md",target:"_blank",rel:"noopener noreferrer"},h=s("h2",{id:"3-将-ref-作为参数传递",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#3-将-ref-作为参数传递"},[s("span",null,"3. 将 ref 作为参数传递")])],-1),f=s("p",null,[n("在 Vue 中，我们使用 "),s("code",null,"setup()"),n(" 函数来构建数据和逻辑之间的连接。为了使其灵活，大部分 VueUse 函数也接受参数的 ref 版本。")],-1),E={href:"https://vueuse.org/core/useTitle/",target:"_blank",rel:"noopener noreferrer"},g=s("code",null,"useTitle",-1),v=s("h3",{id:"31-常规用法",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#31-常规用法"},[s("span",null,"3.1 常规用法")])],-1),m={href:"https://vueuse.org/core/useTitle/",target:"_blank",rel:"noopener noreferrer"},F=s("code",null,"useTitle",-1),A=t(`<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> isDark</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useDark</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> title</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useTitle</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&#39;Set title&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">watch</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">isDark</span><span style="color:#D4D4D4;">, () </span><span style="color:#569CD6;">=&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">  title</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;"> = </span><span style="color:#9CDCFE;">isDark</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;"> ? </span><span style="color:#CE9178;">&#39;🌙 Good evening!&#39;</span><span style="color:#D4D4D4;"> : </span><span style="color:#CE9178;">&#39;☀️ Good morning!&#39;</span></span>
<span class="line"><span style="color:#D4D4D4;">})</span></span>
<span class="line"></span></code></pre></div><h3 id="32-连接使用" tabindex="-1"><a class="header-anchor" href="#32-连接使用"><span>3.2 连接使用</span></a></h3><p>如果用 “连接” 的思想来写，你可以传递一个 ref，使其与页面的标题绑定。</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> isDark</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useDark</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> title</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">computed</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#9CDCFE;"> isDark</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;"> ? </span><span style="color:#CE9178;">&#39;🌙 Good evening!&#39;</span><span style="color:#D4D4D4;"> : </span><span style="color:#CE9178;">&#39;☀️ Good morning!&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">useTitle</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">title</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre></div><h3 id="33-响应式-getter" tabindex="-1"><a class="header-anchor" href="#33-响应式-getter"><span>3.3 响应式 Getter</span></a></h3><p>从 VueUse 9.0 开始，我们引入了一个新的约定，将响应式 Getter 作为参数传递。这在处理响应式对象和 Reactivity Transform 中非常有效。</p><div class="language-typescript" data-ext="ts" data-title="ts"><pre class="shiki dark-plus" style="background-color:#1E1E1E;color:#D4D4D4;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">const</span><span style="color:#4FC1FF;"> isDark</span><span style="color:#D4D4D4;"> = </span><span style="color:#DCDCAA;">useDark</span><span style="color:#D4D4D4;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">useTitle</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">=&gt;</span><span style="color:#9CDCFE;"> isDark</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;"> ? </span><span style="color:#CE9178;">&#39;🌙 Good evening!&#39;</span><span style="color:#D4D4D4;"> : </span><span style="color:#CE9178;">&#39;☀️ Good morning!&#39;</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre></div>`,7);function _(k,x){const a=p("router-link"),o=p("ExternalLinkIcon");return r(),D("div",null,[y,s("nav",d,[s("ul",null,[s("li",null,[e(a,{to:"#1-解构"},{default:l(()=>[n("1. 解构")]),_:1})]),s("li",null,[e(a,{to:"#2-清除副作用"},{default:l(()=>[n("2. 清除副作用")]),_:1})]),s("li",null,[e(a,{to:"#3-将-ref-作为参数传递"},{default:l(()=>[n("3. 将 ref 作为参数传递")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#31-常规用法"},{default:l(()=>[n("3.1 常规用法")]),_:1})]),s("li",null,[e(a,{to:"#32-连接使用"},{default:l(()=>[n("3.2 连接使用")]),_:1})]),s("li",null,[e(a,{to:"#33-响应式-getter"},{default:l(()=>[n("3.3 响应式 Getter")]),_:1})])])])])]),u,s("p",null,[n("了解更多关于作用范围的描述，阅读 "),s("a",C,[n("Vue RFC: Reactivity Effect"),e(o)]),n(" 了解更多。")]),h,f,s("p",null,[n("下面以 "),s("a",E,[g,e(o)]),n(" 为例，展示各种 ref 传参用法。")]),v,s("p",null,[n("通常，"),s("a",m,[F,e(o)]),n(" 返回一个页面标题的引用。当你给这个引用分配新的值时，它会自动更新标题。")]),A])}const R=c(i,[["render",_],["__file","index.html.vue"]]),T=JSON.parse('{"path":"/vue/vueuse/chapter02/","title":"2. VueUse 最佳实践","lang":"zh-CN","frontmatter":{"description":"2. VueUse 最佳实践 Vue3 Ref 对象 在下文及后续文档中，Ref 对象指的是由 ref() 创建的响应式对象，也可以写作 ref，ref 的类型是 Ref。当宽泛地指代可能不止一个 Ref 对象时，使用 refs。 1. 解构 VueUse 中的大多数函数都会返回一个 Ref 对象，你可以使用 ES6 的对象解构语法来获取你需要的东西，...","head":[["meta",{"property":"og:url","content":"https://blog.alexsun.top/vuepress-frontend-notes/vuepress-frontend-notes/vue/vueuse/chapter02/"}],["meta",{"property":"og:site_name","content":"前端笔记"}],["meta",{"property":"og:title","content":"2. VueUse 最佳实践"}],["meta",{"property":"og:description","content":"2. VueUse 最佳实践 Vue3 Ref 对象 在下文及后续文档中，Ref 对象指的是由 ref() 创建的响应式对象，也可以写作 ref，ref 的类型是 Ref。当宽泛地指代可能不止一个 Ref 对象时，使用 refs。 1. 解构 VueUse 中的大多数函数都会返回一个 Ref 对象，你可以使用 ES6 的对象解构语法来获取你需要的东西，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-04T11:44:04.000Z"}],["meta",{"property":"article:author","content":"鸭梨"}],["meta",{"property":"article:modified_time","content":"2024-05-04T11:44:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2. VueUse 最佳实践\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-04T11:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"鸭梨\\",\\"url\\":\\"https://blog.alexsun.top/\\"}]}"]]},"headers":[{"level":2,"title":"1. 解构","slug":"1-解构","link":"#1-解构","children":[]},{"level":2,"title":"2. 清除副作用","slug":"2-清除副作用","link":"#2-清除副作用","children":[]},{"level":2,"title":"3. 将 ref 作为参数传递","slug":"3-将-ref-作为参数传递","link":"#3-将-ref-作为参数传递","children":[{"level":3,"title":"3.1 常规用法","slug":"31-常规用法","link":"#31-常规用法","children":[]},{"level":3,"title":"3.2 连接使用","slug":"32-连接使用","link":"#32-连接使用","children":[]},{"level":3,"title":"3.3 响应式 Getter","slug":"33-响应式-getter","link":"#33-响应式-getter","children":[]}]}],"git":{"createdTime":1674796029000,"updatedTime":1714823044000,"contributors":[{"name":"Sun-ZhenXing","email":"1006925066@qq.com","commits":1}]},"readingTime":{"minutes":2.23,"words":669},"filePathRelative":"vue/vueuse/chapter02/index.md","localizedDate":"2023年1月27日","autoDesc":true}');export{R as comp,T as data};
